// 2022-08-17
// 2590 색종이
// https://www.acmicpc.net/problem/2590
/*
    그리디, 구현 (2,020KB, 0ms)
    시간 복잡도: ?
    풀이)
    - 최대한 적은 개수의 판을 사용해야 하므로, 큰 색종이를 먼저 사용한다.
    - 6x6은 개수만큼 판을 사용해야 한다.
    - 5x5은 개수만큼 판을 사용해야 한다.
    또한, 개수만큼 1x1를 11개 추가할 수 있다.
    - 4x4는 개수만큼 판을 사용해야 한다.
    또한, 개수만큼 2x2를 5개 혹은 1x1를 20개 추가할 수 있다.
     - 큰 종이를 먼저 사용해야 하므로, 2x2를 사용한다.
     남은 2x2를 추가하며, 만약 2x2를 사용하고도 남은 칸이 있으면, 1x1를 추가한다.
    - 3x3은 한 판에 4개까지 사용할 수 있다. 즉, 4로 나눈 나머지가 0이 아닐 경우, 추가로 한 판을 더 사용해야 한다.
    3x3을 사용하고서 남은 칸에 2x2 혹은 1x1을 추가할 수 있다.
     - 한 판에 사용된 3x3 이외의 자리, 즉 추가할 수 있는 3x3 자리에 2x2 1개, 1x1 5개를 추가할 수 있다.
     만약 추가할 수 있는 3x3이 2개일 경우, 2x2를 한 개 더 추가할 수 있다. (이 경우, 1x1는 4개 줄어듦)
     만약 추가할 수 있는 3x3이 3개일 경우, 2x2를 두 개 더 추가할 수 있다. (이 경우, 1x1는 8개 줄어듦)
     2x2를 추가하고서 남은 자리에 1x1를 추가로 배치한다.
    - 2x2는 한 판에 9개까지 사용할 수 있다. 즉, 9로 나눈 나머지가 0이 아닐 경우, 추가로 한 판을 더 사용해야 한다.
    2x2을 사용하고서 남은 칸에 1x1을 추가한다.
    - 필요한 판의 개수를 출력한다.
    etc.) 빈 판에 3x3을 하나 추가했을 경우, 추가할 수 있는 2x2의 개수가 5개가 아닌 4개인줄 알고 헛짓함
    참고)
    - 3x3에 대해: https://yhwan.tistory.com/20
 */

#include <iostream>

using namespace std;
#define FAST_IO ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

int main()
{
    FAST_IO;

    int v[10]{};
    for (int i = 1; i <= 6; i++)
        cin >> v[i];

    int ans = 0;
    if (v[5])
    {
        ans += v[5];

        v[1] = max(0, v[1] - 11 * v[5]);
    }
    if (v[4])
    {
        ans += v[4];

        int b = 5 * v[4];        // 추가할 수 있는 2x2의 개수
        int used = min(b, v[2]); // 사용한 2x2의 개수
        v[2] -= used, b -= used;
        v[1] = max(0, v[1] - 4 * b);
    }
    if (v[3])
    {
        ans += v[3] / 4 + bool(v[3] % 4), v[3] %= 4;

        int a = 0, b = 0, c = 4 - v[3]; // 추가할 수 있는 1x1, 2x2, 3x3의 개수
        if (c != 4 && c)
        {
            a += c * 5 - ((c - 1) * 4);
            b += c + c - 1;

            if (v[2])
            {
                int used = min(b, v[2]); // 사용한 2x2의 개수
                v[2] -= used, b -= used;
            }

            if (b) // 추가할 수 있는 2x2가 남았을 경우, 1x1로 바꿈
                a += b * 4;

            v[1] = max(0, v[1] - a);
        }
    }
    if (v[2])
    {
        ans += v[2] / 9 + bool(v[2] % 9), v[2] %= 9;

        int a = (9 - v[2]) * 4; // 추가할 수 있는 1x1의 개수
        if (a != 36 && a)
            v[1] = max(0, v[1] - a);
    }
    if (v[1])
        ans += v[1] / 36 + bool(v[1] % 36);

    cout << ans + v[6];
}